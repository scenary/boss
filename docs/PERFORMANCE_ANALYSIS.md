# "이동중" 표시 기능 성능 분석

## 현재 구현 분석

### DB 쿼리 횟수 (채널 선택 1회당)
1. `channelRepository.findById(channelId)` - 1회
2. `userRepository.findById(userId)` - 1회  
3. `channelUserRepository.findByChannelIdAndUserId()` - 1회
4. `channelUserRepository.findByUserIdAndRoomId()` - 1회
5. `channelUserRepository.deleteAll()` - 1회 (DELETE)
6. `channelUserRepository.save()` - 1회 (INSERT, 선택 시)
7. **브로드캐스트 시**: `getRaidRoom(roomId)` - 1회 (복잡한 JOIN 쿼리)

**총 6-7회의 DB 쿼리**

### WebSocket 브로드캐스트
- 채널 선택 시마다 전체 방 데이터를 다시 조회하여 브로드캐스트
- 방에 참여한 모든 사용자에게 전체 데이터 전송

### 성능 문제점
1. **불필요한 전체 데이터 조회**: 채널 선택 시 전체 방 데이터를 다시 조회
2. **중복 브로드캐스트**: 동시에 여러 사용자가 선택하면 각각 브로드캐스트 발생
3. **큰 데이터 전송**: 전체 방 데이터를 매번 전송 (채널 목록, 참가자 등)

## 최적화 방안

### 방안 1: 증분 업데이트 (권장)
- 채널 선택 시 변경된 정보만 브로드캐스트
- 예: `{ type: 'channel_selection', userId: 123, channelId: 5, action: 'select' }`
- 클라이언트에서 로컬 상태만 업데이트

### 방안 2: 디바운싱
- 짧은 시간(예: 100ms) 내 여러 업데이트를 묶어서 한 번만 브로드캐스트
- 동시에 여러 사용자가 선택해도 1회만 브로드캐스트

### 방안 3: 캐싱 최적화
- `getRaidRoom` 결과를 더 오래 캐싱
- 브로드캐스트 시 캐시된 데이터 사용

### 방안 4: 배치 처리
- 여러 채널 선택을 배치로 처리
- 트랜잭션 범위 최적화

## 예상 부하 (사용자 10명 기준)
- **현재**: 채널 선택 1회당 ~7개 쿼리 + WebSocket 브로드캐스트
- **10명이 동시 선택**: 70개 쿼리 + 10번 브로드캐스트
- **최적화 후**: 채널 선택 1회당 ~6개 쿼리 + 증분 브로드캐스트
- **10명이 동시 선택**: 60개 쿼리 + 1번 브로드캐스트 (디바운싱)

## 결론
현재 구현은 **소규모 사용자(10-20명)**에게는 문제없지만, **대규모 사용자(50명 이상)**에서는 부하가 발생할 수 있습니다.

**권장**: 방안 1 (증분 업데이트) + 방안 2 (디바운싱) 조합

